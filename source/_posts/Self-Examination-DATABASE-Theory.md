---
title: Self-Examination DATABASE Theory
date: 2016-09-18 09:42:15
tags: [Database]
---

## For Self-Examination
<!-- more -->

## 1. 概述
> * 数据库(Database DB)

> * 数据库管理系统DBMS (Database Management System)
> DBMS 是位于用户与OS之间的一层数据管理软件，为用户或应用提供访问DB的方法。

> * 数据库系统 DBS
> 实现有组织，动态地存储大量关联数据，方便多用户访问的计算机硬件，软件和数据资源组成的系统。

> 数据库技术中，每个概念都有类型type和值value的区分。

---
### 数据联系

> * 联系(Relationship) 是实体之间的相互关系，与一个联系有关的实体集和数，称为联系的元数。
> 1. 一对一联系
> 2. 一对多联系
> 3. 多对多联系


### 数据模型
> * Data Model 数据模型: 描述数据库的结构和语义。
> 1. 概念模型：表达用户需求观点的数据全局逻辑结构。
> 该模型独立于硬件和软件。硬件独立意味着概念模型不依赖于硬件设备，软件独立意味着该模型不依赖于实现实时的DBMS 软件。因此硬件或软件的变化都不会影响DB的概念模型设计。
>
> 2. 逻辑模型：计算机实现观点的DB全局逻辑结构模型。
> 逻辑模型独立于硬件，但依赖于软件DBMS。是数据库设计人员与应用程序员之间进行交流的工具。
> 
> 3. 外部模型：表达用户使用观点的DB局部逻辑模型。
> 外部模型独立于硬件，依赖于软件。其反映了用户使用数据库的观点
>
> 4. 内部模型：表达DB物理结构的模型。
> 也称物理模型，最底层的抽象。描述了数据在磁盘的存储方式(文件的结构)，存取设备(外存的空间分配)和存取方法(主索引和辅助索引) 
>

> * 关系模型(Relational Model)
> 使用二维表格表达实体集，由若干个关系模式(Relational Schema) 组成的集合。
> 关系模式相当于记录类型，他的实例称为关系(Relation), 每个关系实际上是一张二维表格(Table)
> 相比于层次模型和网状模型更简单.



---
> * 三层模式体系结构
> 
> 1. 数据定义语言DDL(Data Definition Language): 定义DB的三个层次，外部模型，逻辑模型，内部模型。
> 
> 2. 数据操纵语言DML(Data Maniipulation Language): 对数据库进行操作。这样程序员不需要关心逻辑模式，只与外模式发生联系，按照外模式的结构存储并操作数据。
>
> 


---
> DBMS：数据库的核心组成部分。定义、查询、更新及各种控制都是通过DBMS操作。


---
> 数据库系统中存放的三级结构定义的数据库称为数据字典(Data Dictionary, DD)


---
> 存储管理器提供存储在数据库中的低层数据和应用程序，查询结构。
> 1. 权限和完整性管理器：测试应用程序对数据库的修改是否满足完整性约束。检查用户访问数据的合法性。
> 2. 数据管理器： DBS的逻辑工作单元称为事务(Transaction), 事务由对DB的操作序列组成。事务管理器用于确保DB一致性状态，保证并反操作的正确执行。
> 3. 文件管理器：负责磁盘空间的合理分配，管理物理文件的存储结构和存取方式。
> 4. 缓冲区管理器： 为应用程序开辟DB的系统缓冲区，负责将磁盘中读取的数据送到内存缓冲区。



---
> * ER模型的基本元素是： 实体，联系和属性

> 实体(Entity) 是一个数据对象，指应用中可以区别的客观存在的事物
> 实体机(Entity Set) 是一指同一类实体构成的集合。
> 实体类型(Entity Type) 是对实体集中实体的定义。


> 联系(Relationship) 表示一个或多个实体之间的关联关系。
> 联系集(Relationship Set) 指同一类联系构成的集合。
> 联系类型(Relationship Type) 是对联系集中联系的定义。

> 属性
> 简单属性(Simple Attribute): 简单属性是不可再分割的属性
> 复合属性(Composite Attribute): 复合属性是可再分解为其他属性的属性(即属性可嵌套)


> 单值属性(Single - Valued Attribute)
> 多值属性(Multi-Valued Attribute)

> 设计全局的ER模型
> 1. 确定公共实体类型
> 2. 合并局部ER模型
> 3. 消除冲突



---
> * 关系模型
> 
> 关系中属性的个数称为元数(Arity)
> 元组个数称为基数(Cardinality)

> 候选键(Candidate Key) 不含有多余属性的超键称为候选键。
> 主键(Primary Key) 用户选作元组标识的候选键称为主键。
> 外键(Foreign Key) 如果模式R中的属性K是其他模式的主键，那么K在模式R中称为外键。


---
> * 在数据库设计中，从子类到超类的抽象画过程称为“概化”， 自底向上的概念综合(Synthesis)， 从超类到子类的具体化过程称为“特化”， 这是自顶向下的概念发挥(Refinement)
> 
> 子类继承超类实体的所有属性，但子类实体本身还可以包含比超类实体更多的属性.



---
> * 为便于阅读，符号规定如下
> 1. 英文首部大写字母: A, B, C...表示单个属性
> 2. 英文尾部大写字母: ..., U, V, W, X, Y, Z 表示属性集
> 3. 大写字母R表示关系模式, 小写r表示其关系。或属性名组合表示关系模式, 若模式A, B, C 有三个属性，就用ABC表示其关系模式
> 4. 属性集[A1, ..., An] 简写A1...An。 属性集X和Y并集 XUY 简写XY， XU[A] 简写为XA或AX


---
> * FD(函数依赖): functional dependency 
> 从A值与B值有一对多联系，可以写出函数依赖 B -> A 
> * 由于函数依赖是用命题形式定义的，因此函数依赖之间存在着逻辑蕴含的关系
> 
> * 模式分解优点
>  模式分解能消除数据冗余和操作异常现象
>  在分解了的数据库中可以存储悬挂元组，存储泛关系中无法存储的信息。
> * 模式分解缺点
> 分解以后，检索操作要做笛卡尔积或连接操作，这将付出时间代价
> 在有泛关系假设时，对数据库中关系进行自然连接时，可能产生寄生元组，即损失了信息。在无泛关系假设时，由于数据库中可能存在悬挂元组，就有可能不存在泛关系


> * 范式(Normal Forms，简称NF): 用于衡量关系模式的好坏 
> 范式的种类与数据依赖有着直接的联系，基于FD的范式有1NF, 2NF, 3NF, BC-NF等

> * 1NF 第一范式
> 如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称R是第一范式。

> * 2NF 第二范式
> 即使关系模式是1NF，但很可能具有不受欢迎的冗余和异常现象。如果关系模式中存在局部依赖，需要把关系模式分解，以排除局部依赖。
> 如果关系模式R是1NF，且每个非主属性完全函数依赖于候选键，那么称R是第二范式的模式。如果数据库模式中每个关系模式都是2NF，则称数据库模式为2NF的数据库模式。

> * 3NF 第三范式
> 如果关系模式R是1NF，且每个非主属性都不传递依赖于R的候选键，那么称R是第三范式的模式。如果数据库模式中的每个关系模式都是3NF，称其为3NF的数据库模式。

> * BCNF (Boyce - Codd NF)
> 如果关系模式R是1NF，且每个属性都不传递依赖于R的候选键，那么成R是BCNF的模式。如果数据库模式中每个关系 模式都是BCNF，则称为BCNF的数据库模式。

> * MVD
> 设U是关系模式R的属性集，X和Y是U的子集，Z = R - X - Y， 小写xyz表示属性集XYZ的值。对于R的关系r，在r中存在元组(x, y1, z1)和(x, y2, z2)时，就也存在元组(x, y2, z2)和(x, y1, z1)，那么称多值依赖(Multivalued Dependency, MVD). X -> -> Y 在模式R上成立。

> * 4NF 第四范式
> 设D是关系模式R上成立的FD和MVD集合。如果D中每个非平凡的MVD X ->-> Y的左部X都是R的超键，那么称R是4NF的模式。


---
### 关系运算

> * 并(Union)
> 设关系R和S具有相同的关系模式，R和S的并是由属于R或属于S的元组构成的集合，记为R U S.

> * 差(Difference)
> 设关系R和S具有相同的关系模式，R和S的差是由属于R但不属于S的元组构成的集合，记为R - S.

> * 笛卡尔积(Cartesian Product)
> 设关系R和S元数分别为r和s，定义R和S的笛卡尔积是一个(r+s)元的元组集合，每个元组的前r个分量(属性值)来自R的一个元组，后s个分量来自S的一个元组，记为R X S

> * 投影(Projection)
> 对一个关系进行垂直分割，消去某些列，并重新安排列的顺序。

> * 选择(Selection)
> 选择操作是根据某些条件对关系做水平分割，即选取符合条件的元组。条件可以命题公式(即计算机语言中的条件表达式) F来表示。
> F的两种成分
> 1. 运算对象： 常数(用引号括起来), 元组分量(属性名或列的序号)
> 2. 运算符：算数比较运算符(<, <=, >, >=, =, !=), 逻辑运算符(A, V, -|).

---
### 关系代数组合

> * 交(Intersection)
> 关系R和S的交是由属于R又属于S的元祖构成的集合。

> * 连接(Join)
> 连接是从关系R和S的笛卡尔积中选取属性值满足某一0操作的元组。记为R|><|S

> * 自然连接(Natural join)
> 两个关系R和S的自然连接操作用R|><|S 表示

> * 除法(Division)
> 设关系R和S的元数分别为r和s(设r> s> 0), 那么R/S 是一个(r-s) 元的元组集合。



> * 域关系演算(Domain Relational Calculus): 类似于元组关系演算，不同之处是用域变量代替元组变量的每一个分量，域变量的变化范围是某个值域而不是一个关系。


> * 在关系代数运算中，笛卡尔积和连接运算是最费时间的。
> 以下启发式规则，对于表达式进行转换，以减少中间关系的大小。
> 1. 尽可能早地执行选择操作
> 2. 尽可能早地执行投影操作
> 3. 避免直接做笛卡尔积，把笛卡尔积操作之前和之后的一连串选择和投影合并起来一起做。


---
### SQL
> * 结构化查询语言SQL(Structured Query Language)
> SQL 语言是介乎关系代数和元组演算之间的一种语言


> * SQL 体系结构
> 关系模式称为基本表(Base Table)
> 存储模式称为存储文件(Stored File)
> 子模式称为视图(View)
> 元组称为行(Row)
> 属性称为列(Column)


> * 索引升序排列用ASC表示
> * 索引序列降序使用DESC表示

> * SELECT ... FROM ... WHERE...
> WHERE 子语句的条件表达式F中可以使用以下运算符
> 算数运算符 < <= > >= = !=
> 逻辑运算符 AND OR NOT
> 集合成员运算符 IN NOT IN
> 谓词 EXISTS   ALL  SOME  UNIQUE 
> 聚合函数 AVG MIN MAX SUM COUNT 

> SELECT 语句完整句法
```
SELECT <目标表的列名或列表达式序列> 
FROM <基本表名和(或) 视图序列>
[WHERE <行条件表达式>]
[GROUP BY <列名序列>
	[HAVING <组条件表达式>]
[ORDER BY <列名 [ASC|DESC] >, ...]
```



> * 外模式一级数据结构的基本单位是视图(view),视图是从若干基本表或其他视图构造出来的表。这种构造方法采用SELECT语句实现。
> CREATE VIEW <视图名> (<列表序列>) 
> AS <SELECT 查询语句>



> * SQL 语言有两种使用方式
> 1. 在交互式终端下使用，称为交互式SQL
> 2. 嵌入在主语言中程序使用，称为嵌入式SQL

---
### 数据库管理

> * 事务(Transaction) 是构成一逻辑工作单元的操作集合，要么完整地执行，要么完全不执行。无论发生任何情况，DBS必须保证事务能正确完整地执行。
> 
> * DBS的主要意图，是执行"事务"。事务是数据库环境中一个逻辑工作单元，相当于操作系统环境中的"进程"概念。


> * 触发器(Trigger)是一个能由系统自动执行对数据库修改的语句。
> 触发器有时也称为主动规则(Active Rule) 或事件-条件-动作规则(Event - Condition - Action Rule, ESA 规则)


